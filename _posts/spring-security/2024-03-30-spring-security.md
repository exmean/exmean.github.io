---
layout: post
title: Spring Security 시작하기
category: Spring Security
permalink: /spring-security/1
---

오늘은 간단한 예제 코드와 함께 `Spring Security`에 대해 제가 학습한 내용을 다뤄보고자 합니다. 학습을 하게 된 계기를 이야기 해보자면... 제가 다니고 있는 회사에서는 **Spring Security**를 사용하지 않고 회원 시스템을 구축했고, 이로 인해 겪었던 많은 불편함이 있었습니다. 로그인 로직에 의도를 알 수 없는 코드들이 엉켜 있다던지, 문서화나 시각화가 되어 있지 않아서 이해하는데 많은 시간이 걸린다던지, 그리고 유저의 권한이나 세션을 검증하는 중복 로직들이 각 서비스 레이어에 존재했습니다. 저는 이런 문제들을 조금이라도 개선하기 위해서 인터셉터를 이용한 공통 모듈을 개발했었는데요! 그럼에도 **Spring Security**를 이용하는 것보다는 소요되는 리소스가 많고 XML로 설정을 하다보니 가독성 측면에서도 이점을 가져가기 어려웠습니다.. 이런저런 다른 이유들도 많지만, 이직하게 될 회사에서 사용할 수도 있고! 개인 프로젝트에서라도 적용해볼 수 있도록 학습을 시작하게 되었습니다.

우선 **Spring Security**를 이해하기 위해서 숙지해야 할 개념들이 있습니다!

# 인증과 인가
개발자들에겐 **보안**이 중요한 과제 중 하나입니다. 보안하면 어떤게 제일 먼저 떠오르시나요? 저는 각종 보안 프로그램으로 막혀 있는 정부 서비스가 생각 납니다.. 만약 제가 주민등록등본이 필요해서 정부24 서비스를 이용한다고 한다면 금융인증서나 공동인증서를 통해 본인임을 확인하는 절차를 거치게 됩니다. 이것을 **인증**이라고 하고, 만약 인증이 실패한다면 등본을 뽑을 수 없고 인증에 성공해야지만 등본을 뽑을 수 있는 권한을 얻게 되는데 이것을 **인가**라고 합니다!
* **인증(Authentication)**: 접근할 수 있는 사람인지 확인하는 절차
* **인가(Authorization)**: 인증된 사람에게 권한을 부여하는 절차

그렇다면 Spring Security는 어떤 구조를 가지고 있고 어떻게 인증과 인가 절차를 수행하는지 알아보도록 하겠습니다.

---

# Spring Security Architecture
## DelegatingFilterProxy
**DelegatingFilterProxy**는 서블릿 컨테이너와 Spring ApplicationContext를 연결시켜주는 역할을 수행합니다. 그렇다면 왜 서블릿 컨테이너와 ApplicationContext를 연결해야하는 걸까요? 서블릿 컨테이너는 실행해야 하는 필터들을 자체적으로 등록하고 실행하지만 Spring ApplicationContext는 실행해야 할 필터들을 Bean으로 등록해 관리하기 때문입니다.